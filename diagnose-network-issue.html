<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç½‘ç»œé—®é¢˜è¯Šæ–­å·¥å…·</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        .status {
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
        }
        .success { background: rgba(34, 197, 94, 0.2); border: 2px solid #22c55e; }
        .warning { background: rgba(251, 191, 36, 0.2); border: 2px solid #fbbf24; }
        .error { background: rgba(239, 68, 68, 0.2); border: 2px solid #ef4444; }
        .info { background: rgba(59, 130, 246, 0.2); border: 2px solid #3b82f6; }
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        .test-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .test-section h3 {
            margin-top: 0;
            color: #fbbf24;
        }
        .test-results {
            max-height: 500px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .diagnostic-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .diagnostic-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
        }
        .diagnostic-item h4 {
            margin-top: 0;
            color: #fbbf24;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #22c55e, #16a34a);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” ç½‘ç»œé—®é¢˜è¯Šæ–­å·¥å…·</h1>
        
        <div class="status info">
            <strong>ğŸ¯ è¯Šæ–­ç›®æ ‡:</strong> åˆ†æ "å‰ç«¯å¼‚æ­¥ä»»åŠ¡å¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•" é”™è¯¯<br>
            <strong>ğŸ“Š è¯Šæ–­èŒƒå›´:</strong> API è¿æ¥ã€ç½‘ç»œå»¶è¿Ÿã€æœåŠ¡å™¨çŠ¶æ€ã€æ–‡ä»¶ä¸Šä¼ èƒ½åŠ›
        </div>

        <div class="diagnostic-grid">
            <div class="diagnostic-item">
                <h4>ğŸŒ åŸºç¡€è¿æ¥æµ‹è¯•</h4>
                <p>æµ‹è¯•å„ä¸ªæœåŠ¡ç«¯ç‚¹çš„å¯è®¿é—®æ€§</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="basicProgress"></div>
                </div>
                <p id="basicStatus">ç­‰å¾…æµ‹è¯•...</p>
            </div>
            
            <div class="diagnostic-item">
                <h4>âš¡ API ç«¯ç‚¹æµ‹è¯•</h4>
                <p>æµ‹è¯•å›¾ç‰‡ç”Ÿæˆ API çš„å“åº”èƒ½åŠ›</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="apiProgress"></div>
                </div>
                <p id="apiStatus">ç­‰å¾…æµ‹è¯•...</p>
            </div>
            
            <div class="diagnostic-item">
                <h4>ğŸ“ æ–‡ä»¶ä¸Šä¼ æµ‹è¯•</h4>
                <p>æµ‹è¯•æ–‡ä»¶ä¸Šä¼ å’Œå¤„ç†èƒ½åŠ›</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="uploadProgress"></div>
                </div>
                <p id="uploadStatus">ç­‰å¾…æµ‹è¯•...</p>
            </div>
            
            <div class="diagnostic-item">
                <h4>ğŸ• ç½‘ç»œå»¶è¿Ÿæµ‹è¯•</h4>
                <p>æµ‹è¯•ç½‘ç»œå»¶è¿Ÿå’Œç¨³å®šæ€§</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="latencyProgress"></div>
                </div>
                <p id="latencyStatus">ç­‰å¾…æµ‹è¯•...</p>
            </div>
        </div>

        <div class="test-section">
            <h3>ğŸ› ï¸ è¯Šæ–­æ“ä½œ</h3>
            <button onclick="runFullDiagnosis()">ğŸ” è¿è¡Œå®Œæ•´è¯Šæ–­</button>
            <button onclick="testBasicConnectivity()">ğŸŒ åŸºç¡€è¿æ¥æµ‹è¯•</button>
            <button onclick="testAPIEndpoints()">âš¡ API ç«¯ç‚¹æµ‹è¯•</button>
            <button onclick="testFileUpload()">ğŸ“ æ–‡ä»¶ä¸Šä¼ æµ‹è¯•</button>
            <button onclick="testNetworkLatency()">ğŸ• å»¶è¿Ÿæµ‹è¯•</button>
            <button onclick="clearResults()">ğŸ§¹ æ¸…ç†ç»“æœ</button>
        </div>

        <div class="test-results" id="testResults"></div>
    </div>

    <script>
        const PROD_URL = 'https://ip-creator-ziyerrs-projects.vercel.app';
        const LOCAL_URL = 'http://localhost:3000';
        const MAQUE_API_URL = 'https://ismaque.org';

        function updateStatus(message, type = 'info') {
            const results = document.getElementById('testResults');
            const div = document.createElement('div');
            div.className = `status ${type}`;
            div.innerHTML = `<strong>${new Date().toLocaleTimeString()}:</strong> ${message}`;
            results.appendChild(div);
            results.scrollTop = results.scrollHeight;
        }

        function updateProgress(elementId, progress, status) {
            document.getElementById(elementId + 'Progress').style.width = progress + '%';
            document.getElementById(elementId + 'Status').textContent = status;
        }

        async function testBasicConnectivity() {
            updateStatus('ğŸŒ å¼€å§‹åŸºç¡€è¿æ¥æµ‹è¯•...', 'info');
            updateProgress('basic', 0, 'å¼€å§‹æµ‹è¯•...');

            const endpoints = [
                { name: 'ç”Ÿäº§ç¯å¢ƒ', url: PROD_URL },
                { name: 'æœ¬åœ°ç¯å¢ƒ', url: LOCAL_URL },
                { name: 'éº»é›€APIä¸»åŸŸå', url: MAQUE_API_URL }
            ];

            let successCount = 0;
            
            for (let i = 0; i < endpoints.length; i++) {
                const endpoint = endpoints[i];
                try {
                    updateStatus(`ğŸ“¡ æµ‹è¯• ${endpoint.name}: ${endpoint.url}`, 'info');
                    
                    const startTime = Date.now();
                    const response = await fetch(endpoint.url, { 
                        method: 'HEAD', 
                        mode: 'no-cors',
                        signal: AbortSignal.timeout(10000) // 10ç§’è¶…æ—¶
                    });
                    const endTime = Date.now();
                    
                    successCount++;
                    updateStatus(`âœ… ${endpoint.name} è¿æ¥æˆåŠŸ (${endTime - startTime}ms)`, 'success');
                    
                } catch (error) {
                    updateStatus(`âŒ ${endpoint.name} è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                }
                
                updateProgress('basic', ((i + 1) / endpoints.length) * 100, `${i + 1}/${endpoints.length} å®Œæˆ`);
            }

            const successRate = (successCount / endpoints.length) * 100;
            updateProgress('basic', 100, `${successCount}/${endpoints.length} æˆåŠŸ (${successRate.toFixed(0)}%)`);
            
            if (successRate < 50) {
                updateStatus('ğŸš¨ åŸºç¡€è¿æ¥æµ‹è¯•å¤±è´¥ç‡è¿‡é«˜ï¼Œå¯èƒ½å­˜åœ¨ç½‘ç»œé—®é¢˜', 'error');
            } else {
                updateStatus('âœ… åŸºç¡€è¿æ¥æµ‹è¯•å®Œæˆ', 'success');
            }
        }

        async function testAPIEndpoints() {
            updateStatus('âš¡ å¼€å§‹ API ç«¯ç‚¹æµ‹è¯•...', 'info');
            updateProgress('api', 0, 'å¼€å§‹æµ‹è¯•...');

            const apiEndpoints = [
                { name: 'ç”Ÿäº§ç¯å¢ƒ API', url: `${PROD_URL}/api/generate-single-image` },
                { name: 'æœ¬åœ°ç¯å¢ƒ API', url: `${LOCAL_URL}/api/generate-single-image` }
            ];

            let successCount = 0;

            for (let i = 0; i < apiEndpoints.length; i++) {
                const endpoint = apiEndpoints[i];
                try {
                    updateStatus(`ğŸ“¡ æµ‹è¯• ${endpoint.name}`, 'info');
                    
                    const startTime = Date.now();
                    const response = await fetch(endpoint.url, { 
                        method: 'HEAD',
                        signal: AbortSignal.timeout(15000) // 15ç§’è¶…æ—¶
                    });
                    const endTime = Date.now();
                    
                    if (response.status === 405 || response.status === 200) {
                        // 405 Method Not Allowed æ˜¯æ­£å¸¸çš„ï¼Œè¯´æ˜ç«¯ç‚¹å­˜åœ¨
                        successCount++;
                        updateStatus(`âœ… ${endpoint.name} ç«¯ç‚¹å¯è®¿é—® (${response.status}, ${endTime - startTime}ms)`, 'success');
                    } else {
                        updateStatus(`âš ï¸ ${endpoint.name} å“åº”å¼‚å¸¸: ${response.status}`, 'warning');
                    }
                    
                } catch (error) {
                    updateStatus(`âŒ ${endpoint.name} æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    
                    if (error.name === 'TimeoutError') {
                        updateStatus(`ğŸ• ${endpoint.name} è¶…æ—¶ - å¯èƒ½æœåŠ¡å™¨å“åº”æ…¢`, 'warning');
                    }
                }
                
                updateProgress('api', ((i + 1) / apiEndpoints.length) * 100, `${i + 1}/${apiEndpoints.length} å®Œæˆ`);
            }

            updateProgress('api', 100, `${successCount}/${apiEndpoints.length} æˆåŠŸ`);
        }

        async function testFileUpload() {
            updateStatus('ğŸ“ å¼€å§‹æ–‡ä»¶ä¸Šä¼ æµ‹è¯•...', 'info');
            updateProgress('upload', 0, 'åˆ›å»ºæµ‹è¯•æ–‡ä»¶...');

            try {
                // åˆ›å»ºä¸€ä¸ªå°çš„æµ‹è¯•å›¾ç‰‡æ–‡ä»¶
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                // ç»˜åˆ¶ä¸€ä¸ªç®€å•çš„æµ‹è¯•å›¾æ¡ˆ
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(0, 0, 50, 50);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(50, 0, 50, 50);
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(0, 50, 50, 50);
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(50, 50, 50, 50);

                updateProgress('upload', 25, 'æµ‹è¯•æ–‡ä»¶åˆ›å»ºå®Œæˆ');

                // è½¬æ¢ä¸º Blob
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                const testFile = new File([blob], 'test-image.png', { type: 'image/png' });
                
                updateStatus(`ğŸ“‹ æµ‹è¯•æ–‡ä»¶ä¿¡æ¯: ${testFile.name}, ${testFile.size} bytes`, 'info');
                updateProgress('upload', 50, 'å¼€å§‹ä¸Šä¼ æµ‹è¯•...');

                // æµ‹è¯•æ–‡ä»¶ä¸Šä¼ åˆ°ç”Ÿäº§ç¯å¢ƒ
                const formData = new FormData();
                formData.append('prompt', 'æµ‹è¯•å›¾ç‰‡ä¸Šä¼ åŠŸèƒ½');
                formData.append('image', testFile);
                formData.append('variationSeed', '0');

                const startTime = Date.now();
                const response = await fetch(`${PROD_URL}/api/generate-single-image`, {
                    method: 'POST',
                    body: formData,
                    signal: AbortSignal.timeout(30000) // 30ç§’è¶…æ—¶
                });
                const endTime = Date.now();

                updateProgress('upload', 75, 'åˆ†æå“åº”...');

                const result = await response.json();
                
                if (response.ok) {
                    updateStatus(`âœ… æ–‡ä»¶ä¸Šä¼ æµ‹è¯•æˆåŠŸ (${endTime - startTime}ms)`, 'success');
                    updateStatus(`ğŸ“Š å“åº”æ•°æ®: ${JSON.stringify(result).substring(0, 100)}...`, 'success');
                } else {
                    updateStatus(`âŒ æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ${response.status}`, 'error');
                    updateStatus(`ğŸ’¥ é”™è¯¯è¯¦æƒ…: ${JSON.stringify(result)}`, 'error');
                    
                    // åˆ†æå…·ä½“é”™è¯¯
                    if (result.details && result.details.includes('arrayBuffer')) {
                        updateStatus(`ğŸ” æ£€æµ‹åˆ°æ–‡ä»¶å¤„ç†é”™è¯¯ - arrayBuffer é—®é¢˜`, 'error');
                    } else if (result.details && result.details.includes('ç½‘ç»œ')) {
                        updateStatus(`ğŸŒ æ£€æµ‹åˆ°ç½‘ç»œè¿æ¥é—®é¢˜`, 'error');
                    } else if (result.details && result.details.includes('API')) {
                        updateStatus(`ğŸ”— æ£€æµ‹åˆ°å¤–éƒ¨ API è¿æ¥é—®é¢˜`, 'error');
                    }
                }

                updateProgress('upload', 100, response.ok ? 'ä¸Šä¼ æˆåŠŸ' : 'ä¸Šä¼ å¤±è´¥');

            } catch (error) {
                updateStatus(`âŒ æ–‡ä»¶ä¸Šä¼ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                updateProgress('upload', 100, 'æµ‹è¯•å¤±è´¥');
                
                if (error.name === 'TimeoutError') {
                    updateStatus(`ğŸ• æ–‡ä»¶ä¸Šä¼ è¶…æ—¶ - å¯èƒ½ç½‘ç»œè¿æ¥ä¸ç¨³å®š`, 'warning');
                } else if (error.message.includes('Failed to fetch')) {
                    updateStatus(`ğŸŒ ç½‘ç»œè¿æ¥é—®é¢˜ - æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨`, 'error');
                }
            }
        }

        async function testNetworkLatency() {
            updateStatus('ğŸ• å¼€å§‹ç½‘ç»œå»¶è¿Ÿæµ‹è¯•...', 'info');
            updateProgress('latency', 0, 'å¼€å§‹æµ‹è¯•...');

            const testCount = 5;
            const latencies = [];

            for (let i = 0; i < testCount; i++) {
                try {
                    updateStatus(`ğŸ“¡ å»¶è¿Ÿæµ‹è¯• ${i + 1}/${testCount}`, 'info');
                    
                    const startTime = Date.now();
                    await fetch(PROD_URL, { 
                        method: 'HEAD', 
                        mode: 'no-cors',
                        signal: AbortSignal.timeout(5000)
                    });
                    const endTime = Date.now();
                    
                    const latency = endTime - startTime;
                    latencies.push(latency);
                    updateStatus(`âš¡ ç¬¬ ${i + 1} æ¬¡æµ‹è¯•: ${latency}ms`, latency < 1000 ? 'success' : 'warning');
                    
                } catch (error) {
                    updateStatus(`âŒ ç¬¬ ${i + 1} æ¬¡å»¶è¿Ÿæµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                }
                
                updateProgress('latency', ((i + 1) / testCount) * 100, `${i + 1}/${testCount} å®Œæˆ`);
                
                // æµ‹è¯•é—´éš”
                if (i < testCount - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            if (latencies.length > 0) {
                const avgLatency = latencies.reduce((a, b) => a + b, 0) / latencies.length;
                const minLatency = Math.min(...latencies);
                const maxLatency = Math.max(...latencies);
                
                updateStatus(`ğŸ“Š å»¶è¿Ÿç»Ÿè®¡: å¹³å‡ ${avgLatency.toFixed(0)}ms, æœ€å° ${minLatency}ms, æœ€å¤§ ${maxLatency}ms`, 'info');
                
                if (avgLatency < 500) {
                    updateStatus('âœ… ç½‘ç»œå»¶è¿Ÿè‰¯å¥½', 'success');
                    updateProgress('latency', 100, `å¹³å‡ ${avgLatency.toFixed(0)}ms (è‰¯å¥½)`);
                } else if (avgLatency < 2000) {
                    updateStatus('âš ï¸ ç½‘ç»œå»¶è¿Ÿè¾ƒé«˜ï¼Œå¯èƒ½å½±å“ç”¨æˆ·ä½“éªŒ', 'warning');
                    updateProgress('latency', 100, `å¹³å‡ ${avgLatency.toFixed(0)}ms (è¾ƒæ…¢)`);
                } else {
                    updateStatus('âŒ ç½‘ç»œå»¶è¿Ÿè¿‡é«˜ï¼Œä¸¥é‡å½±å“ä½¿ç”¨', 'error');
                    updateProgress('latency', 100, `å¹³å‡ ${avgLatency.toFixed(0)}ms (å¾ˆæ…¢)`);
                }
            } else {
                updateProgress('latency', 100, 'æµ‹è¯•å¤±è´¥');
            }
        }

        async function runFullDiagnosis() {
            updateStatus('ğŸ” å¼€å§‹è¿è¡Œå®Œæ•´è¯Šæ–­...', 'info');
            
            await testBasicConnectivity();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testAPIEndpoints();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testNetworkLatency();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testFileUpload();
            
            updateStatus('âœ… å®Œæ•´è¯Šæ–­å®Œæˆï¼è¯·æŸ¥çœ‹ä¸Šè¿°ç»“æœåˆ†æé—®é¢˜åŸå› ã€‚', 'success');
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = '';
            
            // é‡ç½®è¿›åº¦æ¡
            ['basic', 'api', 'upload', 'latency'].forEach(id => {
                updateProgress(id, 0, 'ç­‰å¾…æµ‹è¯•...');
            });
            
            updateStatus('ğŸ§¹ è¯Šæ–­ç»“æœå·²æ¸…ç†', 'info');
        }

        // é¡µé¢åŠ è½½æ—¶çš„æç¤º
        window.onload = function() {
            updateStatus('ğŸš€ ç½‘ç»œé—®é¢˜è¯Šæ–­å·¥å…·å·²åŠ è½½', 'info');
            updateStatus('ğŸ’¡ å»ºè®®å…ˆè¿è¡Œ"å®Œæ•´è¯Šæ–­"æ¥å…¨é¢åˆ†æç½‘ç»œçŠ¶å†µ', 'info');
        };
    </script>
</body>
</html>
