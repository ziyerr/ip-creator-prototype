<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”Ÿäº§ç¯å¢ƒé—®é¢˜è°ƒè¯•å·¥å…·</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        .status {
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
        }
        .success { background: rgba(34, 197, 94, 0.2); border: 2px solid #22c55e; }
        .warning { background: rgba(251, 191, 36, 0.2); border: 2px solid #fbbf24; }
        .error { background: rgba(239, 68, 68, 0.2); border: 2px solid #ef4444; }
        .info { background: rgba(59, 130, 246, 0.2); border: 2px solid #3b82f6; }
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        .test-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .test-section h3 {
            margin-top: 0;
            color: #fbbf24;
        }
        .test-results {
            max-height: 600px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .file-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed #fbbf24;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            cursor: pointer;
            transition: all 0.3s;
        }
        .file-input:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #60a5fa;
        }
        .file-input input {
            display: none;
        }
        .diagnostic-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .diagnostic-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
        }
        .diagnostic-item h4 {
            margin-top: 0;
            color: #fbbf24;
            font-size: 16px;
        }
        .metric {
            font-size: 14px;
            margin: 5px 0;
        }
        .metric-value {
            color: #60a5fa;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” ç”Ÿäº§ç¯å¢ƒé—®é¢˜è°ƒè¯•å·¥å…·</h1>
        
        <div class="status info">
            <strong>ğŸ¯ ç›®æ ‡:</strong> æš´éœ²å’Œè¯Šæ–­çœŸå®çš„APIè¿æ¥é—®é¢˜<br>
            <strong>ğŸš¨ æ¨¡å¼:</strong> ç”Ÿäº§è°ƒè¯•æ¨¡å¼ - ä¸ä½¿ç”¨æ¼”ç¤ºæ•°æ®<br>
            <strong>ğŸ“Š çŠ¶æ€:</strong> å‡†å¤‡åˆ†æç½‘ç»œè¿æ¥å’ŒAPIå“åº”é—®é¢˜
        </div>

        <div class="diagnostic-grid">
            <div class="diagnostic-item">
                <h4>ğŸŒ ç½‘ç»œè¿æ¥</h4>
                <div class="metric">çŠ¶æ€: <span class="metric-value" id="networkStatus">æœªæµ‹è¯•</span></div>
                <div class="metric">å»¶è¿Ÿ: <span class="metric-value" id="networkLatency">-</span></div>
                <div class="metric">ç¨³å®šæ€§: <span class="metric-value" id="networkStability">-</span></div>
            </div>
            
            <div class="diagnostic-item">
                <h4>ğŸ”— API ç«¯ç‚¹</h4>
                <div class="metric">éº»é›€API: <span class="metric-value" id="maqueStatus">æœªæµ‹è¯•</span></div>
                <div class="metric">å“åº”æ—¶é—´: <span class="metric-value" id="apiLatency">-</span></div>
                <div class="metric">é”™è¯¯ç±»å‹: <span class="metric-value" id="errorType">-</span></div>
            </div>
            
            <div class="diagnostic-item">
                <h4>ğŸ“ æ–‡ä»¶å¤„ç†</h4>
                <div class="metric">ä¸Šä¼ èƒ½åŠ›: <span class="metric-value" id="uploadCapability">æœªæµ‹è¯•</span></div>
                <div class="metric">æ–‡ä»¶å¤§å°: <span class="metric-value" id="fileSize">-</span></div>
                <div class="metric">å¤„ç†æ–¹æ³•: <span class="metric-value" id="processingMethod">-</span></div>
            </div>
            
            <div class="diagnostic-item">
                <h4>ğŸ”§ ç¯å¢ƒä¿¡æ¯</h4>
                <div class="metric">æµè§ˆå™¨: <span class="metric-value" id="browserInfo">-</span></div>
                <div class="metric">æ—¶åŒº: <span class="metric-value" id="timezone">-</span></div>
                <div class="metric">è¿æ¥ç±»å‹: <span class="metric-value" id="connectionType">-</span></div>
            </div>
        </div>

        <div class="test-section">
            <h3>ğŸ§ª å®é™…æµ‹è¯•</h3>
            
            <div class="file-input" onclick="triggerFileSelect()">
                <input type="file" id="testImage" accept="image/*,image/jpeg,image/png,image/gif,image/webp" onchange="handleFileSelect(event)">
                <p id="fileSelectText">ğŸ“ ç‚¹å‡»é€‰æ‹©æµ‹è¯•å›¾ç‰‡è¿›è¡ŒçœŸå®APIè°ƒç”¨</p>
                <p style="font-size: 14px; opacity: 0.8;">å°†è¿›è¡ŒçœŸå®çš„éº»é›€APIè°ƒç”¨ï¼Œæš´éœ²å®é™…é”™è¯¯</p>
            </div>

            <div style="margin: 10px 0;">
                <button onclick="triggerFileSelect()" style="background: linear-gradient(45deg, #22c55e, #16a34a);">
                    ğŸ“ é€‰æ‹©å›¾ç‰‡æ–‡ä»¶
                </button>
                <button onclick="createTestImage()" style="background: linear-gradient(45deg, #f59e0b, #d97706);">
                    ğŸ¨ åˆ›å»ºæµ‹è¯•å›¾ç‰‡
                </button>
            </div>

            <div>
                <button onclick="testRealAPI()">ğŸš€ æµ‹è¯•çœŸå®API</button>
                <button onclick="testNetworkConnectivity()">ğŸŒ ç½‘ç»œè¿æ¥æµ‹è¯•</button>
                <button onclick="testEnvironment()">ğŸ”§ ç¯å¢ƒæ£€æµ‹</button>
                <button onclick="exportLogs()">ğŸ“‹ å¯¼å‡ºæ—¥å¿—</button>
                <button onclick="clearResults()">ğŸ§¹ æ¸…ç†</button>
            </div>
        </div>

        <div class="test-results" id="testResults"></div>
    </div>

    <script>
        const PROD_URL = 'https://ip-creator-ziyerrs-projects.vercel.app';
        let selectedFile = null;
        let testLogs = [];

        function log(message, type = 'info') {
            const timestamp = new Date().toISOString();
            const logEntry = { timestamp, message, type };
            testLogs.push(logEntry);
            
            const results = document.getElementById('testResults');
            const div = document.createElement('div');
            div.className = `status ${type}`;
            div.innerHTML = `<strong>${new Date().toLocaleTimeString()}:</strong> ${message}`;
            results.appendChild(div);
            results.scrollTop = results.scrollHeight;
        }

        function updateMetric(id, value) {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = value;
            }
        }

        function triggerFileSelect() {
            const fileInput = document.getElementById('testImage');
            if (fileInput) {
                fileInput.click();
                log('ğŸ“ è§¦å‘æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†', 'info');
            } else {
                log('âŒ æ–‡ä»¶è¾“å…¥å…ƒç´ æœªæ‰¾åˆ°', 'error');
            }
        }

        function handleFileSelect(event) {
            log('ğŸ“ æ–‡ä»¶é€‰æ‹©äº‹ä»¶è§¦å‘', 'info');

            if (!event || !event.target) {
                log('âŒ äº‹ä»¶å¯¹è±¡æ— æ•ˆ', 'error');
                return;
            }

            const files = event.target.files;
            if (!files || files.length === 0) {
                log('âš ï¸ æœªé€‰æ‹©æ–‡ä»¶', 'warning');
                return;
            }

            const file = files[0];
            if (!file) {
                log('âŒ æ–‡ä»¶å¯¹è±¡æ— æ•ˆ', 'error');
                return;
            }

            selectedFile = file;
            log(`âœ… æ–‡ä»¶é€‰æ‹©æˆåŠŸ: ${file.name} (${(file.size / 1024).toFixed(1)}KB, ${file.type})`, 'success');

            // æ›´æ–°UIæ˜¾ç¤º
            const fileSelectText = document.getElementById('fileSelectText');
            if (fileSelectText) {
                fileSelectText.textContent = `âœ… å·²é€‰æ‹©: ${file.name}`;
            }

            updateMetric('fileSize', `${(file.size / 1024).toFixed(1)}KB`);

            // æ£€æŸ¥æ–‡ä»¶å¤„ç†æ–¹æ³•
            const methods = [];
            if (typeof file.arrayBuffer === 'function') methods.push('arrayBuffer');
            if (typeof file.stream === 'function') methods.push('stream');
            if (typeof file.text === 'function') methods.push('text');

            updateMetric('processingMethod', methods.join(', ') || 'æ— å¯ç”¨æ–¹æ³•');
            updateMetric('uploadCapability', 'å·²å‡†å¤‡');

            log(`ğŸ” æ–‡ä»¶å¤„ç†æ–¹æ³•: ${methods.join(', ') || 'æ— å¯ç”¨æ–¹æ³•'}`, methods.length > 0 ? 'info' : 'warning');
            log(`ğŸ“‹ æ–‡ä»¶è¯¦ç»†ä¿¡æ¯: ç±»å‹=${file.type}, å¤§å°=${file.size}å­—èŠ‚, æœ€åä¿®æ”¹=${new Date(file.lastModified).toLocaleString()}`, 'info');
        }

        function createTestImage() {
            log('ğŸ¨ åˆ›å»ºæµ‹è¯•å›¾ç‰‡...', 'info');

            try {
                // åˆ›å»ºä¸€ä¸ªç®€å•çš„æµ‹è¯•å›¾ç‰‡
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 200;
                const ctx = canvas.getContext('2d');

                // ç»˜åˆ¶å½©è‰²èƒŒæ™¯
                const gradient = ctx.createLinearGradient(0, 0, 200, 200);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 200, 200);

                // ç»˜åˆ¶æ–‡å­—
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æµ‹è¯•å›¾ç‰‡', 100, 80);

                ctx.font = '16px Arial';
                ctx.fillText(new Date().toLocaleTimeString(), 100, 120);
                ctx.fillText('è°ƒè¯•å·¥å…·ç”Ÿæˆ', 100, 140);

                // è½¬æ¢ä¸º Blob
                canvas.toBlob((blob) => {
                    if (blob) {
                        const file = new File([blob], 'test-image.png', { type: 'image/png' });
                        selectedFile = file;

                        log(`âœ… æµ‹è¯•å›¾ç‰‡åˆ›å»ºæˆåŠŸ: ${file.name} (${(file.size / 1024).toFixed(1)}KB)`, 'success');

                        // æ›´æ–°UI
                        const fileSelectText = document.getElementById('fileSelectText');
                        if (fileSelectText) {
                            fileSelectText.textContent = `âœ… å·²åˆ›å»ºæµ‹è¯•å›¾ç‰‡: ${file.name}`;
                        }

                        updateMetric('fileSize', `${(file.size / 1024).toFixed(1)}KB`);
                        updateMetric('processingMethod', 'arrayBuffer, stream, text');
                        updateMetric('uploadCapability', 'å·²å‡†å¤‡');

                        log('ğŸ¯ å¯ä»¥å¼€å§‹æµ‹è¯•çœŸå®APIäº†', 'info');
                    } else {
                        log('âŒ åˆ›å»ºæµ‹è¯•å›¾ç‰‡å¤±è´¥', 'error');
                    }
                }, 'image/png');

            } catch (error) {
                log(`âŒ åˆ›å»ºæµ‹è¯•å›¾ç‰‡å¼‚å¸¸: ${error.message}`, 'error');
            }
        }

        async function testRealAPI() {
            if (!selectedFile) {
                log('âŒ è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæµ‹è¯•å›¾ç‰‡', 'error');
                return;
            }

            log('ğŸš€ å¼€å§‹çœŸå®APIæµ‹è¯• - å°†æš´éœ²å®é™…é”™è¯¯', 'info');
            
            try {
                const formData = new FormData();
                formData.append('prompt', 'æµ‹è¯•çœŸå®APIè¿æ¥');
                formData.append('image', selectedFile);
                formData.append('variationSeed', '0');

                log(`ğŸ“¡ å‘é€è¯·æ±‚åˆ°: ${PROD_URL}/api/generate-single-image`, 'info');
                log(`ğŸ“‹ è¯·æ±‚å‚æ•°: prompt=æµ‹è¯•çœŸå®APIè¿æ¥, file=${selectedFile.name}`, 'info');
                
                const startTime = Date.now();
                const response = await fetch(`${PROD_URL}/api/generate-single-image`, {
                    method: 'POST',
                    body: formData
                });
                
                const endTime = Date.now();
                const duration = endTime - startTime;
                
                log(`â±ï¸ è¯·æ±‚è€—æ—¶: ${duration}ms`, 'info');
                log(`ğŸ“Š HTTPçŠ¶æ€: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
                
                updateMetric('apiLatency', `${duration}ms`);
                
                const result = await response.json();
                
                if (response.ok) {
                    log(`âœ… APIè°ƒç”¨æˆåŠŸ!`, 'success');
                    log(`ğŸ“„ å“åº”æ•°æ®: ${JSON.stringify(result, null, 2)}`, 'success');
                    updateMetric('maqueStatus', 'æ­£å¸¸');
                    updateMetric('errorType', 'æ— é”™è¯¯');
                } else {
                    log(`âŒ APIè°ƒç”¨å¤±è´¥`, 'error');
                    log(`ğŸ’¥ é”™è¯¯è¯¦æƒ…: ${JSON.stringify(result, null, 2)}`, 'error');
                    updateMetric('maqueStatus', 'å¤±è´¥');
                    
                    // åˆ†æé”™è¯¯ç±»å‹
                    if (result.details) {
                        if (result.details.includes('arrayBuffer')) {
                            updateMetric('errorType', 'æ–‡ä»¶å¤„ç†é”™è¯¯');
                            log(`ğŸ” æ£€æµ‹åˆ°æ–‡ä»¶å¤„ç†é—®é¢˜: ${result.details}`, 'error');
                        } else if (result.details.includes('Failed to fetch') || result.details.includes('ç½‘ç»œ')) {
                            updateMetric('errorType', 'ç½‘ç»œè¿æ¥é”™è¯¯');
                            log(`ğŸŒ æ£€æµ‹åˆ°ç½‘ç»œè¿æ¥é—®é¢˜: ${result.details}`, 'error');
                        } else if (result.details.includes('API') || result.details.includes('401') || result.details.includes('404')) {
                            updateMetric('errorType', 'APIç«¯ç‚¹é”™è¯¯');
                            log(`ğŸ”— æ£€æµ‹åˆ°APIç«¯ç‚¹é—®é¢˜: ${result.details}`, 'error');
                        } else {
                            updateMetric('errorType', 'æœªçŸ¥é”™è¯¯');
                            log(`â“ æœªçŸ¥é”™è¯¯ç±»å‹: ${result.details}`, 'error');
                        }
                    }
                }
                
            } catch (error) {
                log(`âŒ è¯·æ±‚å¼‚å¸¸: ${error.message}`, 'error');
                updateMetric('maqueStatus', 'å¼‚å¸¸');
                
                if (error.message.includes('Failed to fetch')) {
                    updateMetric('errorType', 'CORS/ç½‘ç»œé”™è¯¯');
                    log(`ğŸŒ ç½‘ç»œè¿æ¥é—®é¢˜: æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨`, 'error');
                } else if (error.name === 'TypeError') {
                    updateMetric('errorType', 'ç±»å‹é”™è¯¯');
                    log(`ğŸ”§ ç±»å‹é”™è¯¯: å¯èƒ½æ˜¯ä»£ç é—®é¢˜`, 'error');
                } else {
                    updateMetric('errorType', 'æœªçŸ¥å¼‚å¸¸');
                    log(`â“ æœªçŸ¥å¼‚å¸¸ç±»å‹: ${error.name}`, 'error');
                }
            }
        }

        async function testNetworkConnectivity() {
            log('ğŸŒ å¼€å§‹ç½‘ç»œè¿æ¥æµ‹è¯•...', 'info');
            
            const endpoints = [
                { name: 'ç”Ÿäº§ç¯å¢ƒ', url: PROD_URL },
                { name: 'éº»é›€APIä¸»åŸŸå', url: 'https://ismaque.org' },
                { name: 'Google DNS', url: 'https://8.8.8.8' }
            ];
            
            let successCount = 0;
            const latencies = [];
            
            for (const endpoint of endpoints) {
                try {
                    log(`ğŸ“¡ æµ‹è¯•è¿æ¥: ${endpoint.name}`, 'info');
                    
                    const startTime = Date.now();
                    const response = await fetch(endpoint.url, { 
                        method: 'HEAD', 
                        mode: 'no-cors',
                        signal: AbortSignal.timeout(10000)
                    });
                    const endTime = Date.now();
                    const latency = endTime - startTime;
                    
                    latencies.push(latency);
                    successCount++;
                    log(`âœ… ${endpoint.name} è¿æ¥æˆåŠŸ (${latency}ms)`, 'success');
                    
                } catch (error) {
                    log(`âŒ ${endpoint.name} è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                }
            }
            
            const avgLatency = latencies.length > 0 ? latencies.reduce((a, b) => a + b, 0) / latencies.length : 0;
            const successRate = (successCount / endpoints.length) * 100;
            
            updateMetric('networkStatus', `${successCount}/${endpoints.length} æˆåŠŸ`);
            updateMetric('networkLatency', `${avgLatency.toFixed(0)}ms`);
            updateMetric('networkStability', `${successRate.toFixed(0)}%`);
            
            if (successRate < 50) {
                log('ğŸš¨ ç½‘ç»œè¿æ¥ä¸ç¨³å®šï¼Œå¯èƒ½å½±å“APIè°ƒç”¨', 'error');
            } else {
                log('âœ… ç½‘ç»œè¿æ¥æ­£å¸¸', 'success');
            }
        }

        function testEnvironment() {
            log('ğŸ”§ æ£€æµ‹ç¯å¢ƒä¿¡æ¯...', 'info');
            
            // æµè§ˆå™¨ä¿¡æ¯
            const browserInfo = `${navigator.userAgent.split(' ').slice(-2).join(' ')}`;
            updateMetric('browserInfo', browserInfo);
            log(`ğŸŒ æµè§ˆå™¨: ${browserInfo}`, 'info');
            
            // æ—¶åŒºä¿¡æ¯
            const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            updateMetric('timezone', timezone);
            log(`ğŸ• æ—¶åŒº: ${timezone}`, 'info');
            
            // è¿æ¥ä¿¡æ¯
            if ('connection' in navigator) {
                const connection = navigator.connection;
                const connectionType = `${connection.effectiveType || 'unknown'} (${connection.downlink || 'unknown'}Mbps)`;
                updateMetric('connectionType', connectionType);
                log(`ğŸ“¶ è¿æ¥ç±»å‹: ${connectionType}`, 'info');
            } else {
                updateMetric('connectionType', 'ä¸æ”¯æŒæ£€æµ‹');
                log(`ğŸ“¶ è¿æ¥ä¿¡æ¯: æµè§ˆå™¨ä¸æ”¯æŒæ£€æµ‹`, 'warning');
            }
            
            // å…¶ä»–ç¯å¢ƒä¿¡æ¯
            log(`ğŸ–¥ï¸ å±å¹•åˆ†è¾¨ç‡: ${screen.width}x${screen.height}`, 'info');
            log(`ğŸ’¾ æœ¬åœ°å­˜å‚¨å¯ç”¨: ${typeof(Storage) !== "undefined"}`, 'info');
            log(`ğŸ”§ Service Workeræ”¯æŒ: ${typeof(navigator.serviceWorker) !== "undefined"}`, 'info');
            
            log('âœ… ç¯å¢ƒæ£€æµ‹å®Œæˆ', 'success');
        }

        function exportLogs() {
            const logData = {
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                url: window.location.href,
                logs: testLogs
            };
            
            const blob = new Blob([JSON.stringify(logData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `debug-logs-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            log('ğŸ“‹ è°ƒè¯•æ—¥å¿—å·²å¯¼å‡º', 'success');
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = '';
            testLogs = [];
            
            // é‡ç½®æŒ‡æ ‡
            ['networkStatus', 'networkLatency', 'networkStability', 'maqueStatus', 'apiLatency', 'errorType', 'uploadCapability', 'fileSize', 'processingMethod', 'browserInfo', 'timezone', 'connectionType'].forEach(id => {
                updateMetric(id, id.includes('Status') || id.includes('Capability') ? 'æœªæµ‹è¯•' : '-');
            });
            
            log('ğŸ§¹ è°ƒè¯•ç»“æœå·²æ¸…ç†', 'info');
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ£€æµ‹ç¯å¢ƒ
        window.onload = function() {
            log('ğŸš€ ç”Ÿäº§ç¯å¢ƒè°ƒè¯•å·¥å…·å·²åŠ è½½', 'info');
            log('âš ï¸ æ³¨æ„: æ­¤å·¥å…·å°†è¿›è¡ŒçœŸå®APIè°ƒç”¨ï¼Œæš´éœ²å®é™…é”™è¯¯', 'warning');
            testEnvironment();
        };
    </script>
</body>
</html>
